# CPU

## Architecture

* IA-32: intelの32bit
  * i386: intelの16bit x86を32bitに拡張
  * i686
* IA-64: intelの64bit
  * IA-32とは互換性なし
* x86-64: AMD64
  * IA-32と互換性有り
  * Intel 64は互換性ある

## I/O

CPUの命令実行により、CPUから外部へアクセスする仕組みと定義。  

* CPUと外部のI/Oデバイス(display, keyboard network)はバスを介して接続する。  
  * メモリとの接続は高速になるように設計されている。  
  * バス関連の仕様としてPCI Expressがある
* I/Oアクセスとは、I/Oデバイスに対する単純なリード及びライト操作
* I/Oアクセス命令には２つの系統がある
  * memory mapped I/O
    * I/Oデバイスをメモリのようにみせる
    * 物理アドレス空間に対して通常の命令で操作する
  * I/O専用命令をI/O専用の物理メモリアドレス空間で実行する
    * x86にはin,out命令がある

### Hardwareによる支援

#### DMA

DMA (Direct Memory Access)はCPUを介さずにメモリ間でデータを転送する仕組み。  
CPUとは別に搭載されたDMAコントローラが指示されkjた転送アドレスと転送先アドレスの間で指示された量のデータ転送を行う。  I/OデバイスはメモリマップドI/Oによって物理アドレス空間にマッピングされているので、DMAを用いることでI/Oデバイスとメモリ間でデータ転送が可能になる。

DMAコントローラはCPUからはI/Oデバイスの1つとして見える。  
CPUからDMAコントローラへの指示はI/Oライトアクセスによって行う。

また、DMAコントローラへの指示をI/Oデバイスから出せる場合もある。



## 命令流の特別な切り替え

例外(exception), 割り込み(interrupt), trap, fault, abort, error, software interrupt, systemcall等によって発生する命令流の切り替えについて。

CPUによって用語の使い方に差がある。  メンタルモデルとして以下を採用する。  

* システムコール: 特権レベルの変更命令によって明示的に発生させる命令流の切り替え
* 例外: 命令実行時に発生する稀なケースをhardware側で検出した際、暗黙的に発生する命令流の切り替え
* 割り込み: 外部からの要求による命令流の切り替え


### Systemcall

CPUで提供されている専用命令で行う。  
実行することによって特権レベルを変更し、ハンドラに命令流が切り替わる。  
ハンドラから元のプロセスに戻り、特権レベルも元に戻すには戻り専用の命令を実行する。  
この戻り専用命令は例外ハンドラや割り込みハンドラから戻る場合にも用いられる。


### 例外

ゼロ除算等。命令を続行できない状況をhardwareで検出して、命令流を切り替える。  

ページフォルトも例外に含まれる。


### 割り込み

外部からの要求により命令流を切り替える事象。  
CPUとI/Oデバイスの間には、割り込みコントローラーが介在する。割り込みコントローラーもCPUから見るとI/Oデバイスに見える。  

割り込みの仕様は同じCPU Archでも世代によって異なったりするらしい。


### 例外 割り込み時の振る舞い

いずれの原因にせよ、CPUが自動的にPC registerを更新し、命令流を切り替える。  
切り替え先の命令列はhandlerと呼ばれる。  
命令の切り替え先はベクタテーブルから供給される。ベクターテーブルはメモリ上にある。  
ベクターテーブルには切り替え先の命令アドレスが載っている。   
CPUの特権レベルも変更される。


#### コンテキストの保存

命令流の切り替えは一時的で、元の命令に戻る必要がある。  
そのため、事象発生時の命令流切り替え時点の情報(戻り先命令アドレス、register)を特別なregisterに保持しておく必要がある。


## Atomic

### Swap命令

registerの値をメモリに書き込みつつ、書き込み前のメモリの値をregisterに書く。  
swap命令実行後にregisterをみると書き込み前の値がわかる。  
bool(0,1)のlock flagをCPU間で取り合う際に、お互いに1を書き込みつつ、swap後のregisterを見てそれが0の場合だけlockを取得できたと判断したりできる。

```
  mov x2, 1         # lock取得用の1
L_loop:
  swap x2, x1 [x10] # flagにx2(1)を書き込み、値をx1に取得
  cbnz x1, L_loop   # x1が0でなかったら繰り返し
```

### CAS

Compare and Swap命令。atomic界の中心的人物。  
以下のように動作する

1. メモリからreg-2に値を読む
2. reg-2とreg-1(前もって値を設定)を比較する
3. reg-2とreg-1が一致していた場合のみ、reg-3の値をメモリに書き込み


```
L_loop:
  ldr x1, [x10]     # counterの値をx1にload
  mov x2, x1        # loadしたx1をx2に保持
  add x5, x1, 1     # 1を加算
  cas x1, x5, [x10] # x1と同じならx5を書き込む
  cmp x1, x2        # cas操作の成否を確認
  bne L_loop        # 失敗していればやり直し
```


